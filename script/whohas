#!/usr/bin/perl

# whohas, a Perl utility to display availability of source
# and binary packages from major Linux and BSD distributions
#
# Copyright (C) Philipp L. Wesche 2005-2008
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use sigtrap;

#TODO fedora needs to print output
#TODO get more info about slackware, debian and ubuntu packages from subsequent links

my $netbsdbase = "ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/";


use Env qw(HOME);
use threads;

my $confdir = "$HOME/.whohas";
# make .whohas directory in home directory
unless (-d $confdir) {
	mkdir ($confdir, 0777);
}

my @columns = (11,25,10,4,10,11);
my $cols = 6;

my $arch_bool		= 1;
my $debian_bool		= 1;
my $fink_bool		= 1;
my $freebsd_bool	= 1;
my $macports_bool	= 1;
my $netbsd_bool		= 1;
my $openbsd_bool	= 1;
my $opensuse_bool	= 1;
my $slack_bool		= 1;
my $sourcemage_bool	= 1;
my $ubuntu_bool		= 1;

my @thrs;
my $here = 0;

if (@ARGV > 1) {
	for (my $i = 0; $i < @ARGV; $i++) {
		if ($ARGV[$i] eq "-d") {
			$arch_bool			= 0;
			$debian_bool		= 0;
			$fink_bool			= 0;
			$freebsd_bool		= 0;
			$macports_bool		= 0;
			$netbsd_bool		= 0;
			$openbsd_bool		= 0;
			$opensuse_bool		= 0;
			$slack_bool			= 0;
			$sourcemage_bool	= 0;
			$ubuntu_bool		= 0;
			my @parts = split /,/, $ARGV[$i+1];
			for (my $a = 0; $a < @parts; $a++) {
				if (		$parts[$a] =~ /archlinux/i) {
					$arch_bool			= 1;
				} elsif (	$parts[$a] =~ /debian/i) {
					$debian_bool		= 1;
				} elsif (	$parts[$a] =~ /fink/i) {
					$fink_bool			= 1;
				} elsif (	$parts[$a] =~ /freebsd/i) {
					$freebsd_bool		= 1;
				} elsif (	$parts[$a] =~ /macports/i) {
					$macports_bool		= 1;
				} elsif (	$parts[$a] =~ /netbsd/i) {
					$netbsd_bool		= 1;
				} elsif (	$parts[$a] =~ /openbsd/i) {
					$openbsd_bool		= 1;
				} elsif (	$parts[$a] =~ /opensuse/i) {
					$opensuse_bool		= 1;
				} elsif (	$parts[$a] =~ /slackware/i) {
					$slack_bool			= 1;
				} elsif (	$parts[$a] =~ /sourcemage/i) {
					$sourcemage_bool	= 1;
				} elsif (	$parts[$a] =~ /ubuntu/i) {
					$ubuntu_bool		= 1;
				}
			}
			splice @ARGV, $i, 2;
			last;
		}
	}
}

if (@ARGV == 1) {
	if ($ARGV[0] eq "whohasme") {
		my $motto = "You have yourself - that ought to be enough!\n";
		exit;
	} else {
		if ($arch_bool == 1) {
			$thrs[$here++] = threads->new(\&arch,		$ARGV[0]);
			$thrs[$here++] = threads->new(\&aur,		$ARGV[0]);
		}
		if ($debian_bool == 1) {
			$thrs[$here++] = threads->new(\&debian,		$ARGV[0]);
		}
		if ($fink_bool == 1) {
			$thrs[$here++] = threads->new(\&fink,		$ARGV[0]);
		}
		if ($freebsd_bool == 1) {
			$thrs[$here++] = threads->new(\&freebsd,	$ARGV[0]);
		}
		if ($macports_bool == 1) {
			$thrs[$here++] = threads->new(\&macports,	$ARGV[0]);
		}
		if ($netbsd_bool == 1) {
			$thrs[$here++] = threads->new(\&netbsd,		$ARGV[0]);
		}
		if ($openbsd_bool == 1) {
			$thrs[$here++] = threads->new(\&openbsd,	$ARGV[0]);
		}
		if ($opensuse_bool == 1) {
			$thrs[$here++] = threads->new(\&opensuse,	$ARGV[0]);
		}
		if ($slack_bool == 1) {
			$thrs[$here++] = threads->new(\&slack,		$ARGV[0]);
			$thrs[$here++] = threads->new(\&lp_net,		$ARGV[0]);
		}
		if ($sourcemage_bool == 1) {
			$thrs[$here++] = threads->new(\&sourcemage,	$ARGV[0]);
		}
		if ($ubuntu_bool == 1) {
			$thrs[$here++] = threads->new(\&ubuntu,		$ARGV[0]);
		}
		foreach (@thrs) {
			$_->join;
		}
	}
} elsif ($ARGV[0] eq "--no-threads") {
	if ($arch_bool == 1) {
		&arch(		$ARGV[1]);
		&aur(		$ARGV[1]);
	}
	if ($debian_bool == 1) {
		&debian(	$ARGV[1]);
	}
	if ($fink_bool == 1) {
		&fink(		$ARGV[1]);
	}
	if ($freebsd_bool == 1) {
		&freebsd(	$ARGV[1]);
	}
	if ($macports_bool == 1) {
		&macports(	$ARGV[1]);
	}
	if ($netbsd_bool == 1) {
		&netbsd(	$ARGV[1]);
	}
	if ($openbsd_bool == 1) {
		&openbsd(	$ARGV[1]);
	}
	if ($opensuse_bool == 1) {
		&opensuse(	$ARGV[1]);
	}
	if ($slack_bool == 1) {
		&slack(		$ARGV[1]);
		&lp_net(	$ARGV[1]);
	}
	if ($sourcemage_bool == 1) {
		&sourcemage($ARGV[1]);
	}
	if ($ubuntu_bool == 1) {
		&ubuntu(	$ARGV[1]);
	}
} else {
	die "Too many parameters. Usage: $0 [--no-threads] pkgname\n";
}


sub ubuntu {
	my $base = "http://packages.ubuntu.com";
	my $query = $base."/cgi-bin/search_packages.pl?keywords=$_[0]&searchon=names&subword=1&version=all&release=all";
	my @lines = split /\n/, &fetchdoc($query);
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my @groups;
	my $now = 0;
	for (my $i = 0; $i<@lines; $i++) {
		if ($lines[$i] =~ /<h3>Package /) {
			my $name = (split /h3>Package |<\/h3>/, $lines[$i])[1];
			push @names, $name;
			my @parts = split /href\=\"|\"\>|<\/a\>/, $lines[$i+3];
			$parts[4] =~ s/ \(|\)://g;
			push @groups, $parts[4];
			push @repos, "";
			push @urls,  $base.$parts[2];
			push @sizes, "";
			push @dates, "";
			@parts = split />|: /, $lines[$i+6];
			push @versions, $parts[1];
			$i += 11;
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Ubuntu",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub lp_net {
	my $version = "12.1";
	my @lines = split /\n/, &fetchdoc("http://www.linuxpackages.net/search_view.php?by=name&name=".$_[0]."&ver=".$version);
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /<tr bgcolor="#ffffff"><td>/) {
			push @names,    (split /">|<\/a/,   $lines[$i+1])[1];
			push @versions, (split /<\/td/,     $lines[$i+3])[0];
			push @repos,    (split /<\/td/,     $lines[$i+5])[0];
			my $url = (split /href="|">/, $lines[$i+8])[1];
			my @ret = &lp_net_details($url);
			push @urls, $url;
			push @sizes, $ret[0];
			push @dates, $ret[1];
			$i += 10;
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"lp.net",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub lp_net_details {
	my $size;
	my $date;
	my $findd = 0;
	my $finds = 0;
	my @lines = split /\n/, &fetchdoc($_[0]);
	for (my $i = 340; $i < @lines;$i++) {
		if ($lines[$i] =~ /Date :/) {
			if ($findd == 1) {
				die "encountered several dates for package\n";
			} else {
				$findd = 1;
			}
			$date = join "", (split //, (split /<b>|<\/b>/, $lines[$i])[1])[0..9];
		}
		if ($lines[$i] =~ /Filesize :/) {
			if ($finds == 1) {
				die "encountered several sizes for package\n";
			} else {
				$finds = 1;
			}
			my $presize = (split / /, (split /<b>|<\/b>/, $lines[$i])[1])[0];
			$size = &size_trim($presize*1000);
		}
	}
	return ($size,$date);
}

sub macports {
	my $baseurl = "http://www.macports.org";
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my @lines = split /\n/, &fetchdoc($baseurl."/ports.php?by=name&substr=".$_[0]);
	for (my $i = 70; $i < @lines; $i++) {
		if ($lines[$i] =~ /<dt><b>/) {
			my @parties = split /\<dt\>\<b\>/, $lines[$i];
			for (my $javar = 1; $javar < @parties; $javar++) {
				my @parts = split /href="|">|<\/a><\/b> |<\/dt/, $parties[$javar];
				push @urls,     $parts[1];
				push @names,    $parts[2];
				push @versions, $parts[3];
				push @repos, "";
				push @sizes, "";
				push @dates, "";
			}
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"MacPorts",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}


sub fink {
	my $baseurl = "http://fink.sourceforge.net/pdb/";
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my @lines = split /\n/, &fetchdoc($baseurl."browse.php?summary=".$_[0]);
	for (my $i = 60; $i < @lines; $i++) {
		if ($lines[$i] =~ /tr class=\"package\"/) {
			if ($lines[$i] =~ /^\<tr class\=\"pdbHeading\"\>/) {
				$lines[$i] =~ s/.*?\<\/tr\>//;
			}
			my @splitty = split /href\=\"|\"\>|\<\/a\>\<\/td\>\<td class=\"packageName\"\>|\<\/td\>\<td\>/, $lines[$i];
			push @urls, $splitty[3];
			push @names, $splitty[4];
			push @versions, $splitty[5];
			push @repos, "";
			push @sizes, "";
			push @dates, "";
		} elsif ($lines[$i] =~ /\<p\>Query took /) {
			last;
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Fink",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub fink_get_details {
	my @repos;
	my @versions;
	my @lines = split /\n/, &fetchdoc($_[0]);
	for (my $i = 60; $i < @lines; $i++) {
		if ($lines[$i] =~ /10\./) {
			my @parts = split /nowrap">|<\/div>/, $lines[$i];
			unless ($parts[5] =~ /not present/ or $parts[5] =~ /unsupported/) {
				if ($parts[1] =~ /<br>/) {
					push @repos, (split /<br>/, $parts[1])[0];
				} else {
					push @repos, $parts[1];
				}
				$parts[5] =~ s/\<\!\-\-.*\-\-\>//;
				push @versions, $parts[5];
			}
		}
		if ($lines[$i] eq '</table>') {
			last;
		}
	}
	return (\@versions,\@repos);
}


sub fedora_write {
	my $file = $_[1];
	my $arch = $_[2];
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	
	my $baseurl = "ftp://download.fedora.redhat.com/pub/fedora/linux";
	my $tempfile = "$file.tmp";
	
	if (-s $file && ($_[3]==0 || `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6])) {
		# read in
		open IN, $file;
		chomp (my @inlines = <IN>);
		close IN;
		foreach (@inlines) {
			my @parts = split /\t/,$_;
			push @names,    $parts[0];
			push @versions, $parts[1];
			push @dates,    $parts[2];
			push @sizes,    $parts[3];
		}
	} else {
		#download
		system "wget -q $baseurl".$_[0]." -O $tempfile";
		open IN, "$tempfile";
		chomp (my @lines = <IN>);
		close IN;
		system "rm -f $tempfile";
		my $here = 0;
		for (my $i = 0; $i < @lines; $i++) {
			if ($lines[$i] =~ /^  200/) {
				($names[$here],$versions[$here],$dates[$here],$sizes[$here]) = &fedora_analyse($lines[$i],$arch);
				$here++;
			}
		}
		open OUT, ">$file";
		for (my $a = 0; $a < @names; $a++) {
			print OUT "$names[$a]\t$versions[$a]\t$dates[$a]\t$sizes[$a]\n";
		}
		close OUT;
	}
	foreach (@names) {
		push @repos, $_[4];
	}
	return(\@names,\@versions,\@dates,\@sizes,\@repos);
}

sub fedora_analyse {
	my $arch = $_[1];
	my $size = (split /\(|\)/, $_[0])[1];
	$size =~ s/ bytes$//;
	$size =~ s/,//g;
	my $date = join " ", reverse ((split / +/, $_[0])[1..3]);
	chomp ($date = `date +%Y-%m-%d -d \"$date\"`);
	my $nad = (split /">|\.rpm/, $_[0])[2];
	$nad =~ s/\.$arch//g;
	my ($name,$version) = &combos($nad);
	return ($name,$version,$date,$size);
}

sub fedora_wget {
	my $current_release = 4;
	my $distroname = "fc";
	my $arch = "i386";
	my @ininames;
	my @iniversions;
	my @inidates;
	my @inisizes;
	my @inirepos;
	for (my $i = 4; $i <= $current_release; $i++) { # just the one release for now
		my @fed_repos = ("core","updates","extras");
		my @fed_updates = (0,1,1); #whether to ask for an update or not
		my @fed_urls = ("/core/$i/$arch/os/Fedora/RPMS/","/core/updates/$i/$arch/","/extras/$i/$arch/");
		for (my $a = 0; $a < @fed_repos; $a++) {
			my $file = "$confdir/$distroname.$i.".$fed_repos[$a].".list";
			my ($p1,$p2,$p3,$p4,$p5) = &fedora_write($fed_urls[$a],$file,$arch,$fed_updates[$a],$fed_repos[$a]);
			push @ininames,    @$p1;
			push @iniversions, @$p2;
			push @inidates,    @$p3;
			push @inisizes,    @$p4;
			push @inirepos,    @$p5;
		}
	}
	my @names;
	my @repos;
	my @sizes;
	my @versions;
	my @dates;
	my @urls;
	for (my $i = 0; $i < @ininames;$i++) {
		my $mustmatch = $_[0];
		if ($ininames[$i] =~ /$mustmatch/i) {
			push @names,    $ininames[$i];
			push @repos,    $inirepos[$i];
			push @dates,    $inidates[$i];
			push @versions, $iniversions[$i];
			push @sizes,    $inisizes[$i];
			push @urls, "";
		}
		# remove all that are the same
		# i.e. first parsed wins
		for (my $i = 0; $i < @names; $i++) {
			for (my $a = $i + 1; $a < @names; $a++) {
				if ($names[$i] eq $names[$a]) {
					splice (@names,    $i, 1);
					splice (@versions, $i, 1);
					splice (@dates,    $i, 1);
					splice (@sizes,    $i, 1);
					splice (@repos,    $i, 1);
					splice (@urls,     $i, 1);
				}
			}
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Fedora",$names[$i],$versions[$i],
			&size_trim($sizes[$i]),
		$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub size_trim {
	# give at least two significant figures; if a 10^3 edge is encountered, put a dot
	my $leave =  length($_[0]) % 3;
	my $threes = (length($_[0]) - $leave) / 3;
	if ($leave == 0) {
		$leave = 3;
		$threes--;
	}
	
	my @parts = split //, $_[0];
	my $retval = join "", @parts[0..($leave-1)];
	if (length($retval)==1 && $threes > 0) {
		# add one more significant figure
		my $add_sf = $parts[$leave];
		if ($parts[$leave+1] > 4) {
			# rounding
			$add_sf++;
			if ($add_sf == 10) {
				$add_sf = 0;
				$retval++;
				if ($retval == 10) {
					return(&size_trim($retval*(1000**$threes)));
				}
			}
		}
		$retval .= ".$add_sf";
	} elsif (defined($parts[$leave]) && $parts[$leave] > 4) { # instead of defined(...), ($threes > 0) is also possible
		my $before = length($retval);
		# rounding
		$retval++;
		if (length($retval) > $before) {
			return(&size_trim($retval*(1000**$threes)));
		}
	}
	my @suffixes = ("k","M","G");
	if ($threes > 0) {
		$retval .= $suffixes[($threes-1)];
	}
	return $retval;
}


sub freebsd {
	my $query = "http://www.freebsd.org/cgi/ports.cgi?query=".$_[0]."&stype=all";
	my @lines = split /\n/, &fetchdoc($query);
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my $now = 0;
	for (my $i = 50; $i<@lines; $i++) {
		if ($lines[$i] =~ /^<dt><b>/) {
			my $anchor = (split /"/, $lines[$i])[1];
			($names[$now],$versions[$now]) = &combos($anchor);
			push @repos, "";
			push @sizes, "";
			push @urls,  "http://www.freebsd.org/cgi/pds.cgi?ports/www/".$names[$now];
			$now++;
			push @dates, "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"FreeBSD",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub combor {
	my @chars = split //, $_[0];
	my $name;
	my $version;
	for (my $i = @chars - 1; $i >= 0; $i--) {
		if ($chars[$i] !~ /[0-9\-\.]/ && !($chars[$i] eq "i" && $chars[$i-1] eq "-" && $chars[$i+1] =~ /[6543]/)) {
			$name = join "", @chars[0..($i)];
			$version = join "", @chars[($i+2)..(@chars-1)];
			last;
		}
	}
	return($name,$version);
}


sub sourcemage {
	my @grimoires = ("test","stable","games","z-rejected");
	my @lines = split /\n/, &fetchdoc("http://codex.sourcemage.org/listing.txt");
	my @inirepos;
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inidates;
	my @inisizes;
	foreach (@lines) {
		my @comps = split /\^/, $_;
		for (my $a = 0; $a < @grimoires;$a++) {
			if (length($comps[$a+1]) > 0) {
				push @inirepos, $grimoires[$a];
				push @ininames, $comps[0];
				push @iniversions, $comps[$a+1];
				push @inisizes, "";
				push @iniurls,  "";
				push @inidates, "";
			}
		}
	}
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Source Mage",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}


sub search_by_name { # versions, sizes, dates, repos, urls
	my ($p1,$p2,$p3,$p4,$p5,$p6,$search) = @_;
	my @ininames    = @$p1;
	my @iniversions = @$p2;
	my @inisizes    = @$p3;
	my @inidates    = @$p4;
	my @inirepos    = @$p5;
	my @iniurls     = @$p6;
	my @names;
	my @versions;
	my @sizes;
	my @dates;
	my @repos;
	my @urls;
	for (my $i = 0;$i<@ininames;$i++) {
		if ($ininames[$i] =~ /$search/i) {
			push @names,    $ininames[$i];
			push @repos,    $inirepos[$i];
			push @versions, $iniversions[$i];
			push @sizes,    $inisizes[$i];
			push @dates,    $inidates[$i];
			push @urls,     $iniurls[$i];
		}
	}
	return(\@names,\@versions,\@sizes,\@dates,\@repos,\@urls)
}


sub netbsd {
	my $netbsdbase = "ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/";
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inirepos;
	my @inisizes;
	my @inidates;
	my $now = 0;
	my $distroname = "NetBSD";
	my $file = "$confdir/$distroname.list";
	# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy
	if (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {
		open IN, $file;
		chomp (my @lines = <IN>);
		for (my $i = 0; $i<@lines;$i++) {
			($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\t/, $lines[$i];
		}
		close IN;
	} else {
		my @lines = split /\n/, &fetchdoc($netbsdbase."README-all.html");
		for (my $i = 10; $i < @lines; $i++) {
			if ($lines[$i] =~ /^<!-- [0-9A-Za-z]/) {
				my @parts = split / /, $lines[$i];
				($ininames[$now],$iniversions[$now]) = &combos($parts[1]);
				$now++;
				@parts = split /a href="|">/, $lines[$i];
				push @iniurls, $netbsdbase.$parts[1];
				push @inirepos, "";
				push @inisizes, "";
				push @inidates, "";
			}
		}
		open OUT, ">$file";
		for (my $i = 0; $i < @iniurls;$i++) {
			print OUT "$ininames[$i]\t$iniversions[$i]\t$iniurls[$i]\n";
		}
		close OUT;
	}
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub openbsd {
	my $rel = 4.4;
	my $baseurl = "http://www.openbsd.org/".$rel."_packages/";
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inirepos;
	my @inisizes;
	my @inidates;
	my $distroname = "OpenBSD";
	my $file = "$confdir/$distroname\_$rel.list";
	# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy
	if (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {
		open IN, $file;
		chomp (my @lines = <IN>);
		for (my $i = 0; $i<@lines;$i++) {
			($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\t/, $lines[$i];
		}
		close IN;
	} else {
		my @lines = split /\n/, &fetchdoc($baseurl."i386.html");
		my $now = 0;
		for (my $i = 0; $i < @lines; $i++) {
			if ($lines[$i] =~ /^<td><b><a/) {
				my @parts = split />|href=|\.tgz</, $lines[$i];
				push @iniurls, $baseurl.$parts[3];
				($ininames[$now],$iniversions[$now]) = &combos($parts[4]);
				$now++;
				push @inirepos, "";
				push @inisizes, "";
				push @inidates, "";
			}
		}
		open OUT, ">$file";
		for (my $i = 0; $i < @iniurls;$i++) {
			print OUT "$ininames[$i]\t$iniversions[$i]\t$iniurls[$i]\n";
		}
		close OUT;
	}
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub gentoo {
	my $gentoobase = "http://packages.gentoo.org";
	my @names;
	my @versions;
	my @urls;
	my @dates;
	my @lines = split /\n/, &fetchdoc($gentoobase."/search/?sstring=".$_[0]);
	my $name;
	my @repos;
	my @sizes;
	for (my $i = 200; $i < @lines; $i++) { # starting value is a speed compromise
		if ($lines[$i] eq '<table class="ebuild">') {
			$name = (split /fields">|<\/td/, $lines[$i+1])[1];
		} elsif ($lines[$i] =~ /th class="releases/) {
			push @names, $name;
			my @parts = split /href="|" title="|">|<\/a/, $lines[$i];
			push @urls, $parts[2];
			$parts[3] =~ s/ ..:..:..\.00//;
			push @dates,    $parts[3];
			push @versions, $parts[4];
			push @repos, "";
			push @sizes, "";
		}
	}
	my %more_recent;
	for (my $i = 0; $i < @repos; $i++) {
		unless (defined($more_recent{$names[$i]})) {
			&pretty_print($cols,@columns,"Gentoo",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
			$more_recent{$names[$i]} = 1;
		}
	}
	return ();
}

sub combos {
	my @chars = split //, $_[0];
	my $name;
	my $version;
	for (my $i = 0; $i < @chars-1; $i++) {
		if ($chars[$i] eq "-" && $chars[$i+1] =~ /[0-9]/) {
			$name = join "", @chars[0..($i-1)];
			$version = join "", @chars[($i+1)..(@chars-1)];
			last;
		}
	}
	return($name,$version);
}


sub slack {
	my $slackbase  = "http://packages.slackware.it/";
	my @repos;
	my @groups;
	my @names;
	my @versions;
	my @urls;
	my @combos;
	my @sizes;
	my @dates;
	my @lines = split /\n|<br>|<\/td>/, &fetchdoc($slackbase."/search.php?v=current&t=1&q=".$_[0]);
#print "@lines\n";
	my $now = 0;
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /class="pkgtitle"/) {
			my @parts = split /a href="|">|<\/a> in |<\/div>/, $lines[$i];
			$parts[4] =~ s/slackware\///;
			push @groups, $parts[4];
			push @repos, "";
			($names[$now],$versions[$now]) = &combor($parts[3]);
			$now++;
#			push @names, $splitty[0];
#			push @versions, $splitty[1];
			push @urls, $slackbase.$parts[2];
			push @dates, "";
			push @sizes, "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Slackware",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub debian {
	my $debianbase = "http://packages.debian.org";
	my @names;
	my @repos;
	my @groups;
	my @versions;
	my @urls;
	my @sizes;
	my @dates;
	my @lines = split /\n/, &fetchdoc($debianbase."/search?keywords=".$_[0]."&searchon=names&suite=stable&section=all");
	for (my $i = 50; $i < @lines; $i++) {
		if ($lines[$i] =~ /<h3>Package /) {
			my $name = (split /h3>Package |<\/h3>/, $lines[$i])[1];
			push @names, $name;
			my @parts = split /href\=\"|\"\>|<\/a\>/, $lines[$i+3];
			$parts[4] =~ s/ \(|\)://g;
			push @groups, $parts[4];
			push @repos, "";
			push @urls,  $debianbase.$parts[2];
			push @sizes, "";
			push @dates, "";
			@parts = split />|: /, $lines[$i+6];
			push @versions, $parts[1];
			$i += 11;
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Debian",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub aur {
	my $aurbase    = "http://aur.archlinux.org";
	my $stop;
	my @lines = split /\n/, &fetchdoc($aurbase."/packages.php?PP=1000&K=".$_[0]); # 1000 should be enough

	my @repos;
	my @names;
	my @versions;
	my @combos;
	my @dates;
	my @urls;
	my @sizes;
	my @dates;
	my $indicator = 0;
	for (my $i = 100; $i < @lines; $i++) {  # 100 is a compromise between safety and efficiency
		if ($lines[$i] =~ /<td class='data/) {
			$indicator++;
			if ($indicator == 1) {
				push @repos,    &arch_site_get_cont($lines[$i]);
				push @sizes, "";
				push @dates, "";
			} elsif ($indicator == 3) {
				push @combos,    &arch_site_get_cont($lines[$i]);
				push @urls,      $aurbase.&aur_site_get_url ($lines[$i]);
			} elsif ($indicator == 6) {
				$indicator = 0;
			}
			# 2 is package group, 4 is votes, 5 is description, 6 is maintainer
		}
	}
	foreach (@combos) {
		my @units = split / /, $_;
		push @names,    $units[0];
		push @versions, $units[1];
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Arch",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub arch {
	my $archbase   = "http://www.archlinux.org";
	my @lines = split /\n/, &fetchdoc($archbase."/packages/?arch=i686&repo=&q=".$_[0]."&last_update=&limit=all");

	my @repos;
	my @names;
	my @versions;
	my @dates;
	my @urls;
	my @sizes;
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /\<tr class\=\"pkgr/) {
			for (my $a = 2; $a < 8;$a++) {
				my $temp = $lines[$a+$i];
				$temp =~ s/.*\<td\>|\<\/td\>//g;
				if ($a == 2) {
					push @repos,$temp;
				} elsif ($a == 3) {
					push @urls, $archbase.&arch_site_get_url ($lines[$i+$a]);
					push @names, &arch_site_ger_cont($lines[$i+$a]);
				} elsif ($a == 5) {
					$temp =~ s/<span style=\".*\">|<\/span>//g;
					push @versions, $temp;
				} elsif ($a == 9) {
					push @dates,    $temp;
				}
			}
			# 2 is package group, 5 is description
			push @sizes, "";
			$i += 7;
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Arch",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub arch_site_get_url {
	my $temp = $_[0];
	$temp =~ s/.*\<a href=\"|\">.*//g;
	return $temp;
}

sub arch_site_get_cont {
 	my @parts = split />/, $_[0];
 	for (my $i = 0; $i < @parts; $i++) {
 		if ($parts[$i] =~ /^[A-Za-z0-9]/) {
 			return (split /</, $parts[$i])[0];
 		}
 	}
}

sub arch_site_ger_cont {
	my $temp = $_[0];
	$temp =~ s/.*\"\>|\<\/a.*//g;
	return $temp;
}

sub aur_site_get_url {
	my $string = (split /a href='|&O=/, $_[0])[1];
	$string =~ s/\'\>.*//;
	return $string;
}


sub fetchdoc {
	use LWP::UserAgent;

	my $url = $_[0];
	my $silent = 0;
	if (@_ == 2 && $_[1] eq "silent") {
		$silent = 1;
	}

	$url =~ s/\&amp\;/\&/ig;   # convert &amp; to &

	my $ua = LWP::UserAgent->new;
        my @firstline;
        my @response;
        for (my $count = 0; ; ++$count) {   # termination condition inside loop
                my $req = HTTP::Request->new(GET => $url);
                my $res = $ua->request($req)->as_string;
                @response = split (/\n/, $res);
                @firstline = split (/ /, $response[0]);
		my $restest = 0;
		if (@firstline == 3) {
			$restest = $firstline[1];
		} elsif (@firstline > 3) {
			$restest = $firstline[0];
		}
		if ($restest == 200 || $response[0] =~ /200 OK/) { #NB the matching expression added specifically for NetBSD package page!
		# server response 200 is a stringent criterion, but should work
			last;
		} elsif ($count > 4) {   # loop termination condition
			unless ($silent == 1) {
				print ("Tried fetching \"$url\" five times for $_[1]. Giving up.\n");
			}
			return ();
			last;
		}
	}
    my $end = @response - 1;
    my $finaldoc = join ("\n", @response[14..$end]);
    return ($finaldoc);
}

sub pretty_print {
	my $n = $_[0];
	my @colwidths = @_[1..$n];
	my @colvals = @_[($n+1)..(@_-1)];
	for (my $i = 0; $i < @colwidths;$i++) {
		if (length($colvals[$i]) > $colwidths[$i]) {
			my @letters = split //, $colvals[$i];
			print join "", @letters[0..($colwidths[$i]-1)];
			print " ";
		} else {
			print $colvals[$i];
			for (my $a = 0; $a < $colwidths[$i] + 1 - length($colvals[$i]); $a++) {
				print " ";
			}
		}
	}
	print $colvals[@colvals-1]."\n"; #last column is unrestricted in length
}

sub prep_suse_repo {
	if ($_[0] =~ /http\:\/\/download\.opensuse\.org/) {
		if ($_[0] =~ /repositories/) {
			if ($_[0] =~ /home\:/) {
				$_[0] =~ s/^http\:\/\/download\.opensuse\.org\/repositories\/home\:\///;
				$_[0] =~ s/\/openSUSE_11.0//;
				$_[0] =~ s/\:\/.*$//g;
				return $_[0];
			} elsif ($_[0] =~ /http\:\/\/.*:\//) {
				$_[0] =~ s/http\:\/\/download\.opensuse\.org\/repositories\///;
				$_[0] =~ s/\:\/.*//;
				return $_[0];
			} else {
				$_[0] =~ s/http\:\/\/download\.opensuse\.org\/repositories\///;
				$_[0] =~ s/\/.*//;
				return $_[0];
			}
		} elsif ($_[0] eq "http://download.opensuse.org/distribution/11.0/repo/oss/suse") {
			return "suse/oss";
		}
	} elsif ($_[0] eq "http://packman.iu-bremen.de/suse/11.0") {
		return "packman";
	} else {
		return $_[0];
	}
}

sub opensuse {
	my $opensusebase = "http://packages.opensuse-community.org";
	my @names;
	my @repos;
	my @groups;
	my @versions;
	my @urls;
	my @sizes;
	my @dates;
	my $distroname = "openSUSE";
	my @lines = split /\n/, &fetchdoc($opensusebase."/index.jsp?searchTerm=".$_[0]."&distro=openSUSE_110");
	my $temprepo = "";
	for (my $i = 30; $i < @lines; $i++) {		if ($lines[$i] =~ /class\=\"repourl\"\>Results from/) {
			$temprepo = &prep_suse_repo((split /<a href=\"|\<\/a\>|\"\>/, $lines[$i])[3]);
		}
		if ($lines[$i] =~ /class=\"result\"/) {
			my @parts = split /\<a href\=\"\.|\">|\<\/a\>\<\/div\>\<div/, $lines[$i];
			push @repos, $temprepo;
			push @urls, $opensusebase.$parts[6];
			my @splitty = split /\(|\)/, join "",@parts[7..8];
			$splitty[0] =~ s/\<span class=\"highlight|\<\/span\>//g;
			push @names,    $splitty[0];
			push @versions, $splitty[1];
#			print "@parts\n";
			push @sizes,  "";
			push @dates,  "";
			push @groups, "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
}

sub template_query {
	my $query = "url";
	my @lines = split /\n/, &fetchdoc($query);
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my $now = 0;
	for (my $i = 0; $i<@lines; $i++) {
		if ($lines[$i] =~ /unique_tag/) {
			# typically, this is where most of the text processing goes:
			# getting the info and putting it in appropriate arrays

			# use subroutine "combos" if the name and version are represented as, firefox-1.0.6, with the hyphen, and the version number starting with a digit
			my $anchor = "something";
			($names[$now],$versions[$now]) = &combos($anchor);
			$now++;
			push @names,    "";
			push @versions, "";
			push @repos,    "";
			push @sizes,    "";
			push @urls,     "";
			push @dates,    "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Distroname",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub template_listing {
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inirepos;
	my @inisizes;
	my @inidates;
	my $now = 0;
	my $distroname = "mydistro";
	# prepare a list file
	my $file = "$confdir/$distroname.list";
	# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy
	if (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {
		open IN, $file;
		chomp (my @lines = <IN>);
		for (my $i = 0; $i<@lines;$i++) {
			# get back any info that you put in the file
			($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\t/, $lines[$i];
		}
		close IN;
	} else {
		# download fresh copy
		my @lines = split /\n/, &fetchdoc($netbsdbase."README-all.html");
		for (my $i = 0; $i < @lines; $i++) {
			if ($lines[$i] =~ /unique_tag/) {
				# extract all info from the downloaded list
				my @parts = split / /, $lines[$i];
				# use subroutine "combos" to separate name and version number
				($ininames[$now],$iniversions[$now]) = &combos($parts[1]);
				$now++;
				# any info you couldn't get, put a blank in
				push @iniurls,  "";
				push @inirepos, "";
				push @inisizes, "";
				push @inidates, "";
			}
		}
		open OUT, ">$file";
		for (my $i = 0; $i < @iniurls;$i++) {
			# store the available info in the file
			print OUT "$ininames[$i]\t$iniversions[$i]\t$iniurls[$i]\n";
		}
		close OUT;
	}
	# search by hand
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}
